from abc import ABC, abstractmethod

from torch import nn
from torchvision.models import resnet101, ResNet101_Weights


class FeatureExtractor(ABC, nn.Module):
    @property
    @abstractmethod
    def feature_shape(self):
        ...

    @abstractmethod
    def __repr__(self):
        ...



class DummyFeatureExtractor(FeatureExtractor):
    """Feature extractor that ouputs input unchanged

    Use this in a model if the input to the model are already extraced features (e.g. from .h5 files
    generated by this script) and not the images themselves.
    """

    @property
    def feature_shape(self):
        return (0,)

    def forward(self, data):
        return data

    def __repr__(self):
        return f"{self.__class__.__name__}()"


class ResnetFeatureExtractor(FeatureExtractor):
    def __init__(
        self, pretrained=True, fine_tune=False, number_blocks=4, avgpool=True, fc=True
    ) -> None:
        super().__init__()

        self.pretrained = pretrained
        self.fine_tune = fine_tune
        self.number_blocks = number_blocks
        self.avgpool = avgpool
        self.fc = fc

        if pretrained:
            resnet = resnet101(weights=ResNet101_Weights.IMAGENET1K_V2)
        else:
            resnet = resnet101()

        if number_blocks > 4 or number_blocks < 1:
            raise AttributeError("number of blocks need to be between 1 and 3")

        self.resnet = nn.Sequential(*list(resnet.children())[:5])
        self._feature_shape = (256, 56, 56)

        if number_blocks > 1:
            self.resnet.append(resnet.layer2)
            self._feature_shape = (512, 28, 28)

        if number_blocks > 2:
            self.resnet.append(resnet.layer3)
            self._feature_shape = (1024, 14, 14)

        if number_blocks > 3:
            self.resnet.append(resnet.layer4)
            self._feature_shape = (2048, 7, 7)

        if avgpool:
            self.resnet.append(resnet.avgpool)
            self._feature_shape = (2048, 1, 1)

        if fc:
            self.resnet.append(nn.Flatten())
            self.resnet.append(resnet.fc)
            self._feature_shape = (1000,)

        if not fine_tune:
            for param in self.resnet.parameters():
                param.requires_grad = False
            self.resnet.eval()

    @property
    def feature_shape(self):
        return self._feature_shape

    def forward(self, data):
        return self.resnet(data)

    def __repr__(self):
        return f"{self.__class__.__name__}({self.pretrained=}, {self.fine_tune=}, {self.number_blocks=}, {self.avgpool=:=}, {self.fc=})"

